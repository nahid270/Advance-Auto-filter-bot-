# =====================================================================================
# ||      GODFATHER MOVIE BOT (v5.1 - Reliable Admin Reply)                        ||
# ||---------------------------------------------------------------------------------||
# || ‡¶è‡¶á ‡¶∏‡¶Ç‡¶∏‡ßç‡¶ï‡¶∞‡¶£‡ßá ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™ ‡¶ì ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶≠‡ßá‡¶ü ‡¶ö‡ßç‡¶Ø‡¶æ‡¶ü‡ßá‡¶∞ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú ‡¶Ö‡¶ü‡ßã-‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶¨‡ßá‡•§            ||
# || ‡¶ó‡ßç‡¶∞‡ßÅ‡¶™‡ßá ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶®‡¶æ ‡¶™‡ßá‡¶≤‡ßá ‡¶¨‡¶ü ‡¶ö‡ßÅ‡¶™ ‡¶•‡¶æ‡¶ï‡¶¨‡ßá ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶æ‡¶á‡¶≠‡ßá‡¶ü‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶¶‡ßá‡¶¨‡ßá‡•§        ||
# || ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü‡ßá ‡¶™‡ßá‡¶ú‡¶ø‡¶®‡ßá‡¶∂‡¶® (‡¶™‡ßÉ‡¶∑‡ßç‡¶†‡¶æ ‡¶®‡¶Æ‡ßç‡¶¨‡¶∞) ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§                         ||
# || ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ‡¶∞ ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§                       ||
# || ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶®‡¶æ ‡¶™‡ßá‡¶≤‡ßá ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶∞‡¶æ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡¶¨‡ßá‡•§                     ||
# || ‡¶≠‡ßÅ‡¶≤ ‡¶¨‡¶æ‡¶®‡¶æ‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶¨‡¶ü ‡¶è‡¶ñ‡¶® ‡¶∏‡¶†‡¶ø‡¶ï ‡¶®‡¶æ‡¶Æ‡ßá‡¶∞ ‡¶∏‡¶æ‡¶ú‡ßá‡¶∂‡¶® ‡¶¶‡ßá‡¶ñ‡¶æ‡¶¨‡ßá‡•§                          ||
# || ‡¶®‡¶§‡ßÅ‡¶®: ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶∏‡¶ø‡¶∏‡ßç‡¶ü‡ßá‡¶Æ ‡¶Ü‡¶∞‡¶ì ‡¶®‡¶ø‡¶∞‡ßç‡¶≠‡¶∞‡¶Ø‡ßã‡¶ó‡ßç‡¶Ø ‡¶è‡¶¨‡¶Ç ‡¶∏‡ßç‡¶¨‡ßü‡¶Ç‡¶ï‡ßç‡¶∞‡¶ø‡ßü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§       ||
# =====================================================================================

import os
import re
import math
import base64
import logging
import asyncio
from dotenv import load_dotenv
from threading import Thread
from flask import Flask
from pyrogram import Client, filters
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ForceReply
from pyrogram.enums import ChatType
from pyrogram.errors import MessageNotModified
from motor.motor_asyncio import AsyncIOMotorClient
from bson.objectid import ObjectId
from thefuzz import process

# --- ‡¶™‡¶∞‡¶ø‡¶¨‡ßá‡¶∂ ‡¶∏‡ßá‡¶ü‡¶Ü‡¶™ ‡¶ì ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞‡ßá‡¶∂‡¶® ---
load_dotenv()
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
LOGGER = logging.getLogger(__name__)

# --- ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶ø‡¶® ---
FILE_CHANNEL_ID = -1002744890741  # <====== ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ü‡¶∏‡¶≤ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶ö‡ßç‡¶Ø‡¶æ‡¶®‡ßá‡¶≤‡ßá‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶¶‡¶ø‡¶®
if FILE_CHANNEL_ID == 0:
    LOGGER.critical("CRITICAL: Please update the FILE_CHANNEL_ID in the code.")
    exit()

try:
    API_ID, API_HASH, BOT_TOKEN = int(os.environ.get("API_ID")), os.environ.get("API_HASH"), os.environ.get("BOT_TOKEN")
    MONGO_URL, AD_PAGE_URL = os.environ.get("MONGO_URL"), os.environ.get("AD_PAGE_URL")
    ADMIN_IDS = [int(id.strip()) for id in os.environ.get("ADMIN_IDS", "").split(',') if id.strip()]
    LOG_CHANNEL_ID = int(os.environ.get("LOG_CHANNEL_ID"))
    PORT = int(os.environ.get("PORT", 8080))
    DELETE_DELAY, SEARCH_PAGE_SIZE = 15 * 60, 8
except (ValueError, TypeError) as e:
    LOGGER.critical(f"Configuration error in environment variables: {e}")
    exit()

if not all([API_ID, API_HASH, BOT_TOKEN, MONGO_URL, AD_PAGE_URL, ADMIN_IDS, LOG_CHANNEL_ID]):
    LOGGER.critical("One or more environment variables are missing.")
    exit()

# --- ‡¶ï‡ßç‡¶≤‡¶æ‡¶Ø‡¶º‡ßá‡¶®‡ßç‡¶ü, ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶ì ‡¶ì‡ßü‡ßá‡¶¨ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶™ ---
app = Client("MovieBot", api_id=API_ID, api_hash=API_HASH, bot_token=BOT_TOKEN)
mongo_client = AsyncIOMotorClient(MONGO_URL)
db = mongo_client["MovieDB"]
movie_info_db, files_db, users_db = db["movie_info"], db["files"], db["users"]
web_app = Flask(__name__)
@web_app.route('/')
def health_check(): return "Bot is alive and running!"

# ========= üìÑ ‡¶π‡ßá‡¶≤‡ßç‡¶™‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶® ========= #
def is_admin(_, __, message):
    return message.from_user and message.from_user.id in ADMIN_IDS
admin_filter = filters.create(is_admin)

async def delete_messages_after_delay(messages_to_delete, delay):
    await asyncio.sleep(delay)
    for msg in messages_to_delete:
        try:
            if msg: await msg.delete()
        except Exception: pass

# ========= üì¢ ‡¶®‡¶Æ‡¶®‡ßÄ‡¶Ø‡¶º ‡¶á‡¶®‡¶°‡ßá‡¶ï‡ßç‡¶∏‡¶ø‡¶Ç ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ ========= #
@app.on_message(filters.channel & (filters.video | filters.document))
async def flexible_save_movie_quality(client, message):
    if message.chat.id != FILE_CHANNEL_ID: return
    caption = message.caption or ""
    title_match = re.search(r"(.+?)\s*\(?(\d{4})\)?", caption, re.IGNORECASE)
    year = title_match.group(2) if title_match else None
    raw_title = title_match.group(1).strip() if title_match else ' '.join(caption.split()[:5])
    if not raw_title: raw_title = (message.video or message.document).file_name
    
    clean_title = re.sub(r'[\.\_]', ' ', raw_title).strip()
    quality = next((q for q in ["480p", "720p", "1080p", "2160p", "4k"] if q in caption.lower()), "Unknown")
    languages = next((lang.capitalize() for lang in ["hindi", "bangla", "bengali", "english", "tamil", "telugu"] if lang in caption.lower()), "Unknown")
    language = "Bangla" if languages in ["Bangla", "Bengali"] else languages
    
    query = {"title_lower": clean_title.lower()}
    if year: query["year"] = year
    movie_doc = await movie_info_db.find_one_and_update(query, {"$setOnInsert": {"title": clean_title, "year": year, "title_lower": clean_title.lower()}}, upsert=True, return_document=True)
    
    file_info = message.video or message.document
    await files_db.update_one({"movie_id": movie_doc['_id'], "quality": quality, "language": language}, {"$set": {"file_id": file_info.file_id, "chat_id": message.chat.id, "msg_id": message.id}}, upsert=True)
    
    LOGGER.info(f"‚úÖ Indexed: {clean_title} ({year or 'N/A'}) [{quality} - {language}]")

# ========= üëÆ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶® ‡¶ï‡¶Æ‡¶æ‡¶®‡ßç‡¶° ========= #
@app.on_message(filters.command("stats") & admin_filter)
async def stats_command(client, message):
    total_users, total_movies, total_files = await asyncio.gather(users_db.count_documents({}), movie_info_db.count_documents({}), files_db.count_documents({}))
    await message.reply_text(f"üìä **Bot Stats**\n\nüë• Users: `{total_users}`\nüé¨ Movies: `{total_movies}`\nüìÅ Files: `{total_files}`\n\nüì¢ **Indexing Channel:** `{FILE_CHANNEL_ID}`\nüîî **Log Channel:** `{LOG_CHANNEL_ID}`")

@app.on_message(admin_filter & filters.reply)
async def admin_reply_handler(client, message):
    if not (message.reply_to_message and message.reply_to_message.reply_markup and isinstance(message.reply_to_message.reply_markup, ForceReply)): return
    placeholder = message.reply_to_message.reply_markup.placeholder
    if placeholder and placeholder.startswith("reply_to_"):
        try: target_user_id = int(placeholder.split("reply_to_")[1])
        except (ValueError, IndexError): return await message.reply_text("‚ùå ‡¶è‡¶á ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶•‡ßá‡¶ï‡ßá ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶Ü‡¶á‡¶°‡¶ø ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§")
        try:
            await message.copy(chat_id=target_user_id)
            confirmation_msg = await message.reply_text("‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
            asyncio.create_task(delete_messages_after_delay([message.reply_to_message, confirmation_msg, message], 30))
        except Exception as e: await message.reply_text(f"‚ùå ‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•‡•§ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡¶π‡ßü‡¶§‡ßã ‡¶¨‡¶ü‡¶ï‡ßá ‡¶¨‡ßç‡¶≤‡¶ï ‡¶ï‡¶∞‡ßá‡¶õ‡ßá‡•§\n\n**‡¶ï‡¶æ‡¶∞‡¶£:** `{e}`")

@app.on_message(filters.command("del") & admin_filter)
async def delete_movie_command(client, message):
    if len(message.command) < 2: return await message.reply_text("‚ö†Ô∏è **‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞:** `/del <‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶®‡¶æ‡¶Æ>`")
    query = message.text.split(None, 1)[1].strip()
    search_regex = re.compile('.*'.join(query.split()), re.IGNORECASE)
    results = await movie_info_db.find({'title_lower': search_regex}).to_list(length=20)
    if not results: return await message.reply_text(f"‚ùå `'{query}'` ‡¶®‡¶æ‡¶Æ‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§")
    buttons = [[InlineKeyboardButton(f"üóëÔ∏è {movie['title']} {f'({movie['year']})' if movie.get('year') else ''}", callback_data=f"confirmdel_{movie['_id']}")] for movie in results]
    buttons.append([InlineKeyboardButton("üö´ ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡ßÅ‡¶®", callback_data="cancel_delete")])
    await message.reply_text("‚ùì ‡¶Ü‡¶™‡¶®‡¶ø ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶ï‡ßã‡¶®‡¶ü‡¶ø ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶§‡ßá ‡¶ö‡¶æ‡¶®? ‡¶®‡¶ø‡¶∞‡ßç‡¶¨‡¶æ‡¶ö‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®:", reply_markup=InlineKeyboardMarkup(buttons), quote=True)

@app.on_message(filters.command("delall") & admin_filter)
async def delete_all_command(client, message):
    if await movie_info_db.count_documents({}) == 0: return await message.reply_text("‚úÖ ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶Ü‡¶ó‡ßá ‡¶•‡ßá‡¶ï‡ßá‡¶á ‡¶ñ‡¶æ‡¶≤‡¶ø ‡¶Ü‡¶õ‡ßá‡•§")
    markup = InlineKeyboardMarkup([[InlineKeyboardButton("‚úÖ ‡¶π‡ßç‡¶Ø‡¶æ‡¶Å, ‡¶Ü‡¶Æ‡¶ø ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§", callback_data="delall_confirm_yes")], [InlineKeyboardButton("üö´ ‡¶®‡¶æ, ‡¶•‡¶æ‡¶ï", callback_data="cancel_delete")]])
    await message.reply_text(f"üóëÔ∏è **‡¶∏‡¶§‡¶∞‡ßç‡¶ï‡¶¨‡¶æ‡¶∞‡ßç‡¶§‡¶æ!**\n\n‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶•‡ßá‡¶ï‡ßá ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶§‡¶æ‡¶¶‡ßá‡¶∞ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡ßç‡¶•‡¶æ‡ßü‡ßÄ‡¶≠‡¶æ‡¶¨‡ßá ‡¶Æ‡ßÅ‡¶õ‡ßá ‡¶´‡ßá‡¶≤‡¶§‡ßá ‡¶ö‡¶æ‡¶®?\n\n**‡¶è‡¶á ‡¶ï‡¶æ‡¶ú‡¶ü‡¶ø ‡¶Ü‡¶∞ ‡¶´‡ßá‡¶∞‡¶æ‡¶®‡ßã ‡¶Ø‡¶æ‡¶¨‡ßá ‡¶®‡¶æ‡•§**", reply_markup=markup, quote=True)

# ========= ü§ñ ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞‡ßç‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶ï‡¶≤‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ ========= #
@app.on_message(filters.private & filters.command("start"))
async def start_handler(client, message):
    user_id = message.from_user.id
    await users_db.update_one({"_id": user_id}, {"$set": {"name": message.from_user.first_name}}, upsert=True)
    if len(message.command) > 1:
        try:
            decoded_data = base64.urlsafe_b64decode(message.command[1]).decode()
            action, data_id, verified_user_id_str = decoded_data.split('_')
            if user_id != int(verified_user_id_str): return await message.reply_text("üò° ‡¶è‡¶á ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶®‡ßü‡•§")
            if action == "file":
                file_doc = await files_db.find_one({"_id": ObjectId(data_id)})
                if file_doc:
                    movie_doc = await movie_info_db.find_one({"_id": file_doc['movie_id']})
                    final_caption = (f"üé¨ **{movie_doc['title']} {f'({movie_doc['year']})' if movie_doc.get('year') else ''}**\n"
                                     f"‚ú® **Quality:** {file_doc['quality']}\nüåê **Language:** {file_doc['language']}\n\n"
                                     f"üôè Thank you for using our bot!")
                    movie_msg = await client.copy_message(user_id, file_doc['chat_id'], file_doc['msg_id'], caption=final_caption)
                    warning_msg = await message.reply_text(f"‚ùó ‡¶´‡¶æ‡¶á‡¶≤‡¶ü‡¶ø **{DELETE_DELAY // 60} ‡¶Æ‡¶ø‡¶®‡¶ø‡¶ü** ‡¶™‡¶∞ ‡¶Ö‡¶ü‡ßã-‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶π‡ßü‡ßá ‡¶Ø‡¶æ‡¶¨‡ßá‡•§", quote=True)
                    asyncio.create_task(delete_messages_after_delay([movie_msg, warning_msg], DELETE_DELAY))
        except Exception as e: LOGGER.error(f"Deep link error: {e}"); await message.reply_text("ü§î ‡¶≤‡¶ø‡¶ô‡ßç‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡ßç‡¶≠‡¶¨‡¶§ inv√°lid ‡¶¨‡¶æ ‡¶Æ‡ßá‡ßü‡¶æ‡¶¶‡ßã‡¶§‡ßç‡¶§‡ßÄ‡¶∞‡ßç‡¶£‡•§")
    else:
        reply_msg = await message.reply_text(f"üëã Hello, **{message.from_user.first_name}**!\nSend me a movie or series name to search.")
        asyncio.create_task(delete_messages_after_delay([message, reply_msg], 120))

def build_search_results_markup(results, query, current_page, total_count, add_request_button=False):
    buttons = [[InlineKeyboardButton(f"üé¨ {movie['title']} {f'({movie['year']})' if movie.get('year') else ''}", callback_data=f"showqual_{movie['_id']}")] for movie in results]
    if total_count > SEARCH_PAGE_SIZE:
        nav_buttons, total_pages = [], math.ceil(total_count / SEARCH_PAGE_SIZE)
        if current_page > 0: nav_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è ‡¶Ü‡¶ó‡ßá‡¶∞ ‡¶™‡¶æ‡¶§‡¶æ", callback_data=f"nav_{current_page-1}_{query}"))
        nav_buttons.append(InlineKeyboardButton(f"üìÑ {current_page+1}/{total_pages} üìÑ", callback_data="noop"))
        if (current_page + 1) * SEARCH_PAGE_SIZE < total_count: nav_buttons.append(InlineKeyboardButton("‡¶™‡¶∞‡ßá‡¶∞ ‡¶™‡¶æ‡¶§‡¶æ ‚û°Ô∏è", callback_data=f"nav_{current_page+1}_{query}"))
        buttons.append(nav_buttons)
    if add_request_button: buttons.append([InlineKeyboardButton(f"üôè '{query[:20]}' ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®", callback_data=f"reqmovie_{query}")])
    return InlineKeyboardMarkup(buttons)

@app.on_callback_query()
async def callback_handler(client, callback_query):
    data, user_id = callback_query.data, callback_query.from_user.id
    if data == "noop": await callback_query.answer(); return
    if data == "cancel_delete": await callback_query.message.edit_text("üö´ ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶Ö‡¶™‡¶æ‡¶∞‡ßá‡¶∂‡¶® ‡¶¨‡¶æ‡¶§‡¶ø‡¶≤ ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§"); await callback_query.answer(); return

    action = data.split("_", 1)[0]
    
    if action == "showqual":
        movie_id = ObjectId(data.split("_", 1)[1])
        new_msg = await show_quality_options(callback_query.message, movie_id, is_edit=True, return_message=True)
        if new_msg: asyncio.create_task(delete_messages_after_delay([new_msg], DELETE_DELAY))
    elif action == "getfile":
        file_id_str = data.split("_", 1)[1]
        encoded_data = base64.urlsafe_b64encode(f'file_{file_id_str}_{user_id}'.encode()).decode()
        await callback_query.message.edit_reply_markup(InlineKeyboardMarkup([[InlineKeyboardButton("‚úÖ ‡¶≠‡ßá‡¶∞‡¶ø‡¶´‡¶æ‡¶á ‡¶ï‡¶∞‡ßá ‡¶°‡¶æ‡¶â‡¶®‡¶≤‡ßã‡¶° ‡¶ï‡¶∞‡ßÅ‡¶®", url=f"{AD_PAGE_URL}?data={encoded_data}")]]))
    elif action == "nav":
        try:
            _, page_str, query = data.split("_", 2)
            current_page, search_regex = int(page_str), re.compile('.*'.join(query.split()), re.IGNORECASE)
            total_count = await movie_info_db.count_documents({'title_lower': search_regex})
            results = await movie_info_db.find({'title_lower': search_regex}).skip(current_page * SEARCH_PAGE_SIZE).limit(SEARCH_PAGE_SIZE).to_list(length=SEARCH_PAGE_SIZE)
            if results: await callback_query.message.edit_text("ü§î ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶õ‡ßá‡¶®?", reply_markup=build_search_results_markup(results, query, current_page, total_count, True))
        except MessageNotModified: pass
        except Exception as e: LOGGER.error(f"Navigation callback error: {e}"); await callback_query.answer("‡¶ï‡¶ø‡¶õ‡ßÅ ‡¶è‡¶ï‡¶ü‡¶æ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§", show_alert=True)
    elif action == "reqmovie":
        query, user = data.split("_", 1)[1], callback_query.from_user
        admin_message = f"üôè **‡¶®‡¶§‡ßÅ‡¶® ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß**\n\nüë§ **‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ:** {user.mention} (`{user.id}`)\nüé¨ **‡¶Ö‡¶®‡ßÅ‡¶∏‡¶®‡ßç‡¶ß‡¶æ‡¶®:** `{query}`"
        try:
            await client.send_message(LOG_CHANNEL_ID, admin_message, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚úçÔ∏è ‡¶á‡¶â‡¶ú‡¶æ‡¶∞‡¶ï‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶¶‡¶ø‡¶®", callback_data=f"replyuser_{user.id}")]]))
            await callback_query.message.edit_text("‚úÖ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß‡¶ü‡¶ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡ßã ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
            LOGGER.info(f"Movie request for '{query}' from user {user.id} has been forwarded.")
        except Exception as e: LOGGER.error(f"Failed to send request to log channel: {e}"); await callback_query.answer("‚ùå ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶™‡¶æ‡¶†‡¶æ‡¶§‡ßá ‡¶¨‡ßç‡¶Ø‡¶∞‡ßç‡¶•‡•§", show_alert=True)
    elif action == "replyuser":
        if user_id not in ADMIN_IDS: return await callback_query.answer("‚ùå ‡¶è‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§", show_alert=True)
        target_user_id = data.split("_", 1)[1]
        await client.send_message(callback_query.message.chat.id, f"‚úçÔ∏è **‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶ï‡ßá ‡¶∞‡¶ø‡¶™‡ßç‡¶≤‡¶æ‡¶á ‡¶¶‡¶ø‡¶®**\n\nUser ID: `{target_user_id}`\n\n‡¶è‡¶á ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶ï‡ßá ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶§‡ßá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶Æ‡ßá‡¶∏‡ßá‡¶ú‡¶ü‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶™‡¶æ‡¶†‡¶æ‡¶®‡•§", reply_markup=ForceReply(selective=True, placeholder=f"reply_to_{target_user_id}"))
        try: await callback_query.message.delete()
        except: pass
    elif action == "confirmdel":
        if user_id not in ADMIN_IDS: return await callback_query.answer("‚ùå ‡¶è‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§", show_alert=True)
        movie_id = ObjectId(data.split("_", 1)[1])
        movie_doc = await movie_info_db.find_one_and_delete({"_id": movie_id})
        if not movie_doc: return await callback_query.message.edit_text("‚ùå ‡¶è‡¶á ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶á‡¶§‡ßã‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá ‡¶ó‡ßá‡¶õ‡ßá‡•§")
        files_deleted = await files_db.delete_many({"movie_id": movie_id})
        LOGGER.info(f"ADMIN DELETE: User {user_id} deleted movie '{movie_doc['title']}'. {files_deleted.deleted_count} files removed.")
        await callback_query.message.edit_text(f"‚úÖ **'*{movie_doc['title']}*'** ‡¶è‡¶¨‡¶Ç ‡¶è‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶§ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶∏‡¶´‡¶≤‡¶≠‡¶æ‡¶¨‡ßá ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§")
    elif data == "delall_confirm_yes":
        if user_id not in ADMIN_IDS: return await callback_query.answer("‚ùå ‡¶è‡¶ü‡¶ø ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø‡•§", show_alert=True)
        await callback_query.message.edit_text("‚è≥ ‡¶∏‡¶¨ ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶π‡¶ö‡ßç‡¶õ‡ßá...")
        movies_deleted, files_deleted = await movie_info_db.delete_many({}), await files_db.delete_many({})
        LOGGER.warning(f"CRITICAL: User {user_id} deleted ALL data. {movies_deleted.deleted_count} movies, {files_deleted.deleted_count} files removed.")
        await callback_query.message.edit_text(f"‚úÖ **‡¶∏‡¶Æ‡ßç‡¶™‡¶®‡ßç‡¶®!**\n\n- ‡¶Æ‡ßã‡¶ü ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü: `{movies_deleted.deleted_count}`\n- ‡¶Æ‡ßã‡¶ü ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü: `{files_deleted.deleted_count}`")
    
    await callback_query.answer()

async def show_quality_options(message, movie_id, is_edit=False, return_message=False):
    try:
        files = await files_db.find({"movie_id": movie_id}).sort("quality").to_list(length=None)
        movie = await movie_info_db.find_one({"_id": movie_id})
        if not movie: text = "‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶¨‡¶ø‡¶∏‡ßç‡¶§‡¶æ‡¶∞‡¶ø‡¶§ ‡¶§‡¶•‡ßç‡¶Ø ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§"
        elif not files: text = "‡¶¶‡ßÅ‡¶É‡¶ñ‡¶ø‡¶§, ‡¶è‡¶á ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶®‡ßã ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø‡•§"
        else:
            text = f"üé¨ **{movie['title']} {f'({movie['year']})' if movie.get('year') else ''}**\n\nüëá ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶™‡¶õ‡¶®‡ßç‡¶¶‡ßá‡¶∞ ‡¶ï‡ßã‡ßü‡¶æ‡¶≤‡¶ø‡¶ü‡¶ø ‡¶¨‡ßá‡¶õ‡ßá ‡¶®‡¶ø‡¶®:"
            buttons = [[InlineKeyboardButton(f"‚ú® {f['quality']} | üåê {f['language']}", callback_data=f"getfile_{f['_id']}")] for f in files]
            markup = InlineKeyboardMarkup(buttons)
            reply_msg = await message.edit_text(text, reply_markup=markup) if is_edit else await message.reply_text(text, reply_markup=markup, quote=True)
            return reply_msg if return_message else None
        
        reply_msg = await message.edit_text(text) if is_edit else await message.reply_text(text, quote=True)
        return reply_msg if return_message else None
    except MessageNotModified: return message if return_message else None
    except Exception as e: LOGGER.error(f"Show quality options error: {e}"); return None

async def find_suggestions(query, threshold=75, limit=3):
    try:
        all_movies = await movie_info_db.find({}, {"title": 1, "year": 1, "_id": 1}).to_list(length=None)
        if not all_movies: return []
        choices_map = {f"{doc['title']} ({doc.get('year', 'N/A')})": doc['_id'] for doc in all_movies}
        best_matches = process.extract(query, choices_map.keys(), limit=limit)
        return [{"title": movie['title'], "year": movie.get('year'), "_id": choices_map[title_year]} for title_year, score in best_matches if score >= threshold for movie in all_movies if movie['_id'] == choices_map[title_year]]
    except Exception as e: LOGGER.error(f"Error finding suggestions: {e}"); return []

# ========= üîé ‡¶ö‡ßÇ‡ßú‡¶æ‡¶®‡ßç‡¶§ Regex ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö ‡¶π‡ßç‡¶Ø‡¶æ‡¶®‡ßç‡¶°‡¶≤‡¶æ‡¶∞ ========= #
@app.on_message((filters.private | filters.group) & filters.text)
async def reliable_search_handler(client, message):
    if message.text and message.text.startswith('/'): return
    if message.from_user and message.from_user.is_bot: return

    query = message.text.strip()
    cleaned_query = ' '.join(re.findall(r'\b[a-zA-Z0-9]+\b', query.lower()))
    if not cleaned_query: return
    
    search_regex = re.compile('.*'.join(cleaned_query.split()), re.IGNORECASE)
    messages_to_delete, reply_msg = [message], None

    try:
        total_count = await movie_info_db.count_documents({'title_lower': search_regex})
        LOGGER.info(f"Search for '{cleaned_query}' in chat {message.chat.id} ({message.chat.type.name}) found {total_count} results.")
        
        if total_count == 0:
            if message.chat.type == ChatType.PRIVATE:
                suggestions = await find_suggestions(cleaned_query)
                if suggestions:
                    buttons = [[InlineKeyboardButton(f"ü§î {movie['title']} ({movie.get('year', '')})", callback_data=f"showqual_{movie['_id']}")] for movie in suggestions]
                    buttons.append([InlineKeyboardButton(f"üôè '{query[:20]}' ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®", callback_data=f"reqmovie_{query}")])
                    reply_msg = await message.reply_text("‚ùå ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡¶æ‡¶∞‡ßç‡¶ö‡ßá‡¶∞ ‡¶∏‡¶æ‡¶•‡ßá ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶ï‡ßã‡¶®‡ßã ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶Æ‡ßá‡¶≤‡ßá‡¶®‡¶ø‡•§\n\n**‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶õ‡¶ø‡¶≤‡ßá‡¶®?**\n\n‡¶Ø‡¶¶‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶ô‡ßç‡¶ï‡ßç‡¶∑‡¶ø‡¶§ ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡ßá, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§", reply_markup=InlineKeyboardMarkup(buttons), quote=True)
                else:
                    markup = InlineKeyboardMarkup([[InlineKeyboardButton(f"üôè '{query[:20]}' ‡¶è‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶ï‡¶∞‡ßÅ‡¶®", callback_data=f"reqmovie_{query}")]])
                    reply_msg = await message.reply_text("‚ùå **‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡ßá ‡¶™‡¶æ‡¶ì‡ßü‡¶æ ‡¶Ø‡¶æ‡ßü‡¶®‡¶ø!**\n\n‡¶Ü‡¶™‡¶®‡¶ø ‡¶ö‡¶æ‡¶á‡¶≤‡ßá ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßá ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Ö‡ßç‡¶Ø‡¶æ‡¶°‡¶Æ‡¶ø‡¶®‡¶¶‡ßá‡¶∞ ‡¶ï‡¶æ‡¶õ‡ßá ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶ï‡¶∞‡¶§‡ßá ‡¶™‡¶æ‡¶∞‡ßá‡¶®‡•§", reply_markup=markup, quote=True)
                if reply_msg: messages_to_delete.append(reply_msg)
        elif total_count == 1:
            movie = await movie_info_db.find_one({'title_lower': search_regex})
            reply_msg = await show_quality_options(message, movie['_id'], return_message=True)
            if reply_msg: messages_to_delete.append(reply_msg)
        else:
            results = await movie_info_db.find({'title_lower': search_regex}).limit(SEARCH_PAGE_SIZE).to_list(length=SEARCH_PAGE_SIZE)
            markup = build_search_results_markup(results, cleaned_query, 0, total_count, add_request_button=True)
            reply_msg = await message.reply_text("ü§î ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡¶ø ‡¶è‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶ï‡ßã‡¶®‡ßã ‡¶è‡¶ï‡¶ü‡¶ø ‡¶ñ‡ßÅ‡¶Å‡¶ú‡¶õ‡ßá‡¶®? ‡¶Ø‡¶¶‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶ï‡¶æ‡¶ô‡ßç‡¶ï‡ßç‡¶∑‡¶ø‡¶§ ‡¶Æ‡ßÅ‡¶≠‡¶ø‡¶ü‡¶ø ‡¶è‡¶ñ‡¶æ‡¶®‡ßá ‡¶®‡¶æ ‡¶•‡¶æ‡¶ï‡ßá, ‡¶§‡¶æ‡¶π‡¶≤‡ßá ‡¶®‡¶ø‡¶ö‡ßá‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶¨‡¶æ‡¶ü‡¶®‡ßá ‡¶ï‡ßç‡¶≤‡¶ø‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®‡•§", reply_markup=markup, quote=True)
            messages_to_delete.append(reply_msg)
    except Exception as e:
        LOGGER.error(f"Database search error: {e}")
        if message.chat.type == ChatType.PRIVATE:
            reply_msg = await message.reply_text("‚ö†Ô∏è ‡¶¨‡¶ü ‡¶è‡¶ï‡¶ü‡¶ø ‡¶°‡¶æ‡¶ü‡¶æ‡¶¨‡ßá‡¶∏ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡¶∞ ‡¶∏‡¶Æ‡ßç‡¶Æ‡ßÅ‡¶ñ‡ßÄ‡¶® ‡¶π‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡•§")
            messages_to_delete.append(reply_msg)
    finally:
        if messages_to_delete: asyncio.create_task(delete_messages_after_delay(messages_to_delete, DELETE_DELAY))

# ========= ‚ñ∂Ô∏è ‡¶¨‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶ì‡ßü‡ßá‡¶¨ ‡¶∏‡¶æ‡¶∞‡ßç‡¶≠‡¶æ‡¶∞ ‡¶ö‡¶æ‡¶≤‡ßÅ ‡¶ï‡¶∞‡¶æ ========= #
def run_web_server():
    web_app.run(host='0.0.0.0', port=PORT)

if __name__ == "__main__":
    LOGGER.info("Starting web server on a separate thread...")
    web_thread = Thread(target=run_web_server)
    web_thread.start()
    
    LOGGER.info("The Don is waking up... (v5.1 - Reliable Admin Reply)")
    app.run()
    LOGGER.info("The Don is resting...")
